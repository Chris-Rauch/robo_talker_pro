/// File Services class handles all necessary File IO required to parse the Late
/// Payment Report generated by Third Eye. When initialized, it expects the path
/// to file as a string. Can only handle files with the .XLSX extension.
library file_servies;

import 'dart:convert';
import 'dart:developer';
import 'dart:io';
import 'package:excel/excel.dart';
import 'package:path/path.dart' as p;
import 'package:robo_talker_pro/auxillary/shared_preferences.dart';

class FileServices {
  final Excel _latePaymentFile;
  final Excel _reportFile;
  final String _reportFileLocation;
  static const String _reportName = 'report.xlsx';

  FileServices(String filePath, String folderPath)
      : _latePaymentFile = Excel.decodeBytes(File(filePath).readAsBytesSync()),
        _reportFile = Excel.createExcel(),
        _reportFileLocation = p.join(folderPath, _reportName) {
    // make sure the file exists
    if (!File(filePath).existsSync()) {
      throw ArgumentError('File does not exist: $filePath');
    }
    //make sure the file has the correct extension
    if (p.extension(filePath) != '.xlsx') {
      throw ArgumentError(
          'Invalid File Type. Make sure the file extension is .XLSX');
    }
  }

  /// Returns a list of 'contacts' in json format. Moves all exceptions to the
  /// _reportFile located in 'folderPath.'
  Future<String> handleLatePayment() async {
    List<Map<String, dynamic>> contactList = [];
    String contacts = '';
    try {
      String sheetName = _latePaymentFile.getDefaultSheet() ??
          (throw Exception('Cannot access default sheet'));
      Sheet sheet = _latePaymentFile[sheetName];
      for (int x = 2; x < sheet.rows.length; ++x) {
        bool createContact = true;
        var row = sheet.rows[x];
        for (var cell in row) {
          int? columnIndex = cell?.columnIndex;

          // find exceptions
          if (columnIndex == 0) {
            //Agent Name
            if (await _noCallAgreement(cell?.value.toString())) {
              createContact = false;
              _writeRowToFile(row);
            }
          } else if (columnIndex == 1) {
            //Agent Code
          } else if (columnIndex == 2) {
            //Group Type
          } else if (columnIndex == 3) {
            //Contract #
          } else if (columnIndex == 4) {
            //Insured
          } else if (columnIndex == 5) {
            //phone number
            if (_noNumber(cell?.value.toString())) {
              createContact = false;
              _writeRowToFile(row);
            }
            //TODO find duplicate numbers
          } else if (columnIndex == 6) {
            //Intent Date
          } else if (columnIndex == 7) {
            //Cancel Date
          } else if (columnIndex == 8) {
            //Amount Due
          } else {
            //idc
          }
        }

        // if no exceptions were found, create the contact
        if (createContact == true) {
          contactList.add({
            'name': row[4]?.value.toString(), //TODO remove special chars
            'phone': row[5]?.value.toString(),
            'var1': row[0]?.value.toString(), //TODO remove special chars
            'var2': row[8]?.value.toString(), //payment amount
            'var3': row[6]?.value.toString(), //due date
            'var4': _addSpaces(row[3]?.value.toString()), //contract number
          });
        }
      }
      return json.encode(contactList);
    } catch (e) {
      if (e == PathAccessException) {
        //file is open. Close it and try again.
      } else if (e == RangeError) {
        //TODO implement error handling
      }
      log('Error in function handleLatePayments', error: e);
      return '';
    }
  }

  /// Checks to see if argument 'company' is in the No Call Agreement list
  Future<bool> _noCallAgreement(String? company) async {
    List<dynamic> nca = await loadData('nca_list');
    for (var x in nca) {
      if (x.trim() == company?.trim()) {
        return true;
      }
    }
    return false;
  }

  ///Returns true if the argument 'number' is all zero's
  bool _noNumber(String? number) {
    if ((number == '(000) 000-0000') ||
        (number == '0000000000') ||
        (number == '000-000-0000') ||
        (number == '(000)-000-0000') ||
        (number == null)) {
      return true;
    } else {
      return false;
    }
  }

  ///Checks the contactList to see if the phone number is already on file. If a
  ///duplicate number is found, it will compare insured names to determine if
  ///the two rows are really the same person with different contract numbers.
  ///If they're the same the contract number and amount due will be merged into
  ///one contact. Otherwise, they'll both be removed from the
  ///model and placed into the followUp model
  String? _findDuplicateNumbers(
      String? number, List<Map<String, dynamic>> contactList) {
    if (number == null) {
      return null;
    }

    final jsonString = json.encode(contactList);
    if (jsonString.contains(number)) {
      //find out if it's the same contract
      //if it is, add the total amounts together
      //if not, remove from contactList and write to 'report' file
    }
    return '';
  }

  /// Returns the argument but with spaces.
  /// Due to how robotalker.com reads numbers out loud to the user, it's
  /// neccessary to add spaces to the contract numbers.
  String _addSpaces(String? contractNumber) {
    String newString = '';
    if (contractNumber == null) {
      return '';
    }

    //add spaces
    for (int x = 0; x < contractNumber.length; ++x) {
      newString += '${contractNumber[x]} ';
    }

    //pop last char, which should be an extra space
    if (newString.isNotEmpty) {
      newString = newString.substring(0, newString.length - 1);
    }
    return newString;
  }

  /// Appends argument 'row' to _reportFile
  void _writeRowToFile(List<Data?> row) {
    List<CellValue?> cellValues = [];
    try {
      String sheetName = _reportFile.getDefaultSheet() ??
          (throw Exception(
              'Cannot access default sheet')); //get the default sheet name
      Sheet sheet = _reportFile[sheetName]; //initialize the sheet

      for (var cell in row) {
        // Extract the value of each cell and add it to the list
        cellValues.add(cell?.value);
      }
      sheet.appendRow(cellValues);
    } catch (e) {
      log('In function _writeRowToFile:', error: e);
    } finally {
      // Save the Excel file to the specified location
      var file = File(_reportFileLocation);
      file.createSync(recursive: true);
      file.writeAsBytesSync(_reportFile.encode()!);
    }
  }
}
